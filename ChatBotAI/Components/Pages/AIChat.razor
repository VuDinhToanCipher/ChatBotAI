@page "/"
@page "/chat/{conversationId:guid}"
@using ChatApp1.Services
@using ChatBotAI.Application.DTOs.ConversationDTO
@using ChatBotAI.Application.Services.ConversationServices
@using Markdig
@using Microsoft.Extensions.AI
@using System.Text
@using System.ComponentModel
@inject IChatClient ChatClient
@inject NavigationManager Nav
@inject SemanticSearch Search
@implements IDisposable
@rendermode InteractiveServer
@inject IJSRuntime JSRuntime
@using Blazored.SessionStorage
@inject ISessionStorageService session
@inject IConversationService conversation
@inject IMessageService addmessage


<h3>Việt - Hung ChatBot</h3>
<div class="chat-container">
    <div class="chat-messages" @ref="messagesContainer">
        @if (Messages.Count == 0)
        {
            <div class="empty-message">Bắt đầu trò chuyện nào!</div>
        }
        else
        {
            @foreach (var message in Messages)
            {
                <div class="message @(message.IsUser ? "user-message" : "ai-message")">
                    @((MarkupString)Markdown.ToHtml(message.Content ?? ""))
                </div>
            }
        }
    </div>
    <div class="chat-input-area">
        <input type="text"
               @bind="userInput"
               @bind:event="oninput"
               @onkeyup="HandleKeyUp"
               placeholder="Nhập câu hỏi của bạn ..."
               class="chat-input"
               disabled="@isStreaming" />
        <button @onclick="SendMessage" class="send-button" disabled="@isStreaming">
            @(isStreaming ? "Đang xử lý..." : "Gửi")
        </button>
        
    </div>
</div>

@code {
    private const string SystemPrompt = @"
Bạn là trợ lý ảo cho sinh viên khoa Công nghệ Thông tin, giao tiếp hoàn toàn bằng tiếng Việt.
Nhiệm vụ chính của bạn là trả lời các câu hỏi dựa trên dữ liệu và tài liệu của trường (PDF, quy định, hướng dẫn, biểu mẫu, v.v.).

Quy tắc phản hồi:

1. **Chỉ trả lời dựa trên tài liệu**:
   - Khi có thông tin trong tài liệu, trả lời chính xác và tự nhiên.
   - Luôn trích dẫn nguồn theo định dạng XML:
     <citation filename='string' page_number='number'>trích ngắn (≤5 từ) đúng nguyên văn</citation>
   - KHÔNG bịa hoặc suy luận ngoài dữ liệu.

2. **Nếu không tìm thấy thông tin trong tài liệu**:
   - Trả lời: 'Xin lỗi, tôi không tìm thấy thông tin phù hợp trong tài liệu hiện có.'
   - Có thể gợi ý cách tìm thêm thông tin (ví dụ: website chính thức).

3. **Câu hỏi xã giao / mơ hồ**:
   - Trả lời tự nhiên, thân thiện, không tìm kiếm dữ liệu.
   - Ví dụ: 'Chào bạn! Mình có thể giúp gì hôm nay?'

4. **Định dạng**:
   - Dùng Markdown đơn giản: **in đậm**, *in nghiêng*, danh sách gạch đầu dòng.
   - KHÔNG chèn hình ảnh, HTML hoặc text ngoài citation.

5. **Truyền ngữ cảnh RAG**:
   - Luôn ưu tiên lấy dữ liệu từ `SearchAsync`.
   - Nếu dữ liệu trống, không tự sinh câu trả lời khác.
";


    private string userInput = string.Empty;
    private ElementReference messagesContainer;
    private List<MessageDTO> Messages = new();
    private List<ChatMessage> messages = new();
    private bool isStreaming = false;
    private int statefulMessageCount;
    private readonly ChatOptions chatOptions = new();
    private CancellationTokenSource? currentResponseCancellation;
    private Guid? currentConversationId;
    private Guid? userId;
    [Parameter] public Guid? conversationId { get; set; }
    protected override async Task OnInitializedAsync()
    {

        statefulMessageCount = 0;
        messages.Add(new ChatMessage(ChatRole.System, SystemPrompt));
        chatOptions.Tools = [AIFunctionFactory.Create(SearchAsync)];
        if (conversationId.HasValue)
        {
            Messages = await addmessage.GetMessagesByConversationAsync(conversationId.Value);
            currentConversationId = conversationId;
        }
        // Lấy userId từ sessionStorage
        try
        {
            var userIDString = await session.GetItemAsync<string>("UserID");
            if (!string.IsNullOrEmpty(userIDString) && Guid.TryParse(userIDString, out var guid))
            {
                userId = guid;
                Console.WriteLine($"Đã lấy userId: {userId}");
            }
            else
            {
                Console.WriteLine("Không tìm thấy hoặc UserID không hợp lệ trong sessionStorage.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Lỗi khi lấy UserID từ sessionStorage: {ex.Message}");
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(userInput) || isStreaming) return;

        CancelAnyCurrentResponse();

        // Thêm tin nhắn người dùng
        var userMessage = new MessageDTO { Content = userInput, IsUser = true, ConversationId = currentConversationId ?? Guid.Empty };
        Messages.Add(userMessage);
        messages.Add(new ChatMessage(ChatRole.User, userInput));

        // Tạo hội thoại chỉ khi đã đăng nhập
        if (userId.HasValue && currentConversationId == null)
        {
            try
            {
                var title = string.IsNullOrWhiteSpace(userInput) ? "Không có tiêu đề" : userInput.Substring(0, Math.Min(userInput.Length, 50));
                var conversationDTO = new ConversationDTO
                {
                    UserId = userId.Value,
                    Title = title
                };
                var createdConversation = await conversation.AddConversationAsync(conversationDTO);
                if (createdConversation?.ConversationId != Guid.Empty)
                {
                    currentConversationId = createdConversation.ConversationId;
                    userMessage.ConversationId = currentConversationId.Value;
                    // Lưu tin nhắn người dùng
                    await addmessage.AddMessageAsync(userMessage);
                    Console.WriteLine($"Đã tạo hội thoại với ID: {currentConversationId}");
                }
                else
                {
                    Messages.Add(new MessageDTO { Content = "Không thể tạo hội thoại. Vui lòng thử lại.", IsUser = false });
                    Console.WriteLine("Tạo hội thoại thất bại: ConversationId không hợp lệ.");
                    await InvokeAsync(StateHasChanged);
                    return;
                }
            }
            catch (Exception ex)
            {
                Messages.Add(new MessageDTO { Content = "Không thể lưu hội thoại. Vui lòng thử lại.", IsUser = false });
                Console.WriteLine($"Lỗi khi tạo hội thoại: {ex.Message}");
                await InvokeAsync(StateHasChanged);
                return;
            }
        }

        var responseText = new StringBuilder();
        var aiMessage = new MessageDTO { Content = "", IsUser = false, ConversationId = currentConversationId ?? Guid.Empty };
        Messages.Add(aiMessage);
        currentResponseCancellation = new CancellationTokenSource();

        try
        {
            isStreaming = true;
            await InvokeAsync(StateHasChanged);

            // Gọi API AI
            await foreach (var update in ChatClient.GetStreamingResponseAsync(
                messages.Skip(statefulMessageCount), chatOptions, currentResponseCancellation.Token))
            {
                if (update.Text != null)
                {
                    responseText.Append(update.Text);
                    aiMessage.Content = responseText.ToString();
                    await InvokeAsync(StateHasChanged);
                }
            }

            // Lưu tin nhắn AI nếu đã đăng nhập
            if (userId.HasValue && currentConversationId.HasValue)
            {
                try
                {
                    aiMessage.ConversationId = currentConversationId.Value;
                    await addmessage.AddMessageAsync(aiMessage);
                    Console.WriteLine($"Đã lưu tin nhắn AI cho hội thoại: {currentConversationId}");
                }
                catch (Exception ex)
                {
                    aiMessage.Content = $"{aiMessage.Content}\n\n(Lưu tin nhắn thất bại, vui lòng thử lại.)";
                    Console.WriteLine($"Lỗi khi lưu tin nhắn AI: {ex.Message}");
                }
            }

            messages.Add(new ChatMessage(ChatRole.Assistant, responseText.ToString()));
            statefulMessageCount = chatOptions.ConversationId is not null ? messages.Count : 0;
        }
        catch (OperationCanceledException)
        {
            aiMessage.Content = "Đã hủy phản hồi.";
        }
        catch (Exception ex)
        {
            aiMessage.Content = $"Xin lỗi, đã có lỗi xảy ra: Vui lòng thử lại.";
            Console.WriteLine($"Lỗi khi gọi AI: {ex}");
        }
        finally
        {
            isStreaming = false;
            userInput = string.Empty;
            currentResponseCancellation?.Dispose();
            currentResponseCancellation = null;
            await InvokeAsync(StateHasChanged);
            await ScrollToBottom();
        }
    }

    private async Task ScrollToBottom()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("scrollToBottom", messagesContainer);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Lỗi khi cuộn xuống dưới: {ex.Message}");
        }
    }

    private async Task HandleKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !isStreaming)
        {
            await SendMessage();
        }
    }

    private void CancelAnyCurrentResponse()
    {
        if (currentResponseCancellation != null)
        {
            currentResponseCancellation.Cancel();
            currentResponseCancellation.Dispose();
            currentResponseCancellation = null;
        }
    }
    [Description("Searches for information using a phrase or keyword")]
    private async Task<IEnumerable<string>> SearchAsync(
        [Description("The phrase to search for.")] string searchPhrase,
        [Description("If possible, specify the filename to search that file only. If not provided or empty, the search includes all files.")] string? filenameFilter = null)
    {
        var results = await Search.SearchAsync(searchPhrase, filenameFilter, maxResults: 5);
        return results.Select(result =>
            $"<result filename=\"{result.DocumentId}\" page_number=\"{result.PageNumber}\">{result.Text}</result>");
    }

    public void Dispose()
    {
        CancelAnyCurrentResponse();
        GC.SuppressFinalize(this);
    }
}