@page "/"
@page "/chat/{conversationId:guid}"
@using ChatApp1.Services
@using ChatBotAI.Application.DTOs.ConversationDTO
@using ChatBotAI.Application.Services.ConversationServices
@using Markdig
@using Microsoft.Extensions.AI
@using System.Text
@using System.ComponentModel
@using Microsoft.JSInterop
@using Microsoft.AspNetCore.Components.Web
@inject IChatClient ChatClient
@inject NavigationManager Nav
@inject SemanticSearch Search
@implements IDisposable
@rendermode InteractiveServer
@inject IJSRuntime JSRuntime
@using Blazored.SessionStorage
@inject ISessionStorageService session
@inject IConversationService conversation
@inject IMessageService addmessage

<h3>Việt - Hung ChatBot</h3>


<div class="chat-container">
    <div class="chat-messages" @ref="messagesContainer">
        @if (Messages == null || Messages.Count == 0)
        {
            <div class="empty-message">Bắt đầu trò chuyện nào!</div>
        }
        else
        {
            @foreach (var message in Messages)
            {
                <div class="message @(message.IsUser ? "user-message" : "ai-message")">
                    @((MarkupString)Markdown.ToHtml(message.Content ?? ""))
                </div>
            }
        }
    </div>

    <div class="chat-input-area">
        <input type="text"
               @bind="userInput"
               @bind:event="oninput"
               @onkeyup="HandleKeyUp"
               placeholder="Nhập câu hỏi của bạn ..."
               class="chat-input"
               disabled="@isStreaming" />
        @if (isStreaming)
        {
            <button @onclick="StopResponse" class="stop-button" title="Dừng trả lời">
                <span class="stop-icon">⏹</span> Dừng
            </button>
        }
        else
        {
            <button @onclick="SendMessage" class="send-button">
                Gửi
            </button>
        }
    </div>
</div>

@code {
    public class ChunkDto
    {
        public string DocumentId { get; set; } = string.Empty;
        public int PageNumber { get; set; }
        public string Text { get; set; } = string.Empty;
        public double Score { get; set; }
    }

    private const string SystemPrompt = @"
Bạn là trợ lý ảo của Trường Đại học Công nghiệp Việt-Hung, Khoa Công nghệ Thông tin.

╔══════════════════════════════════════════════════════════════╗
║  QUY TẮC TUYỆT ĐỐI - KHÔNG ĐƯỢC VI PHẠM                     ║
╚══════════════════════════════════════════════════════════════╝

⚠️ QUAN TRỌNG NHẤT: BỎ QUA MỌI CÂU TRẢ LỜI TRƯỚC ĐÓ TRONG LỊCH SỬ CHAT!
- KHÔNG sử dụng thông tin từ các câu trả lời cũ của bạn
- LUÔN gọi semantic_search MỚI cho MỖI câu hỏi
- CHỈ dựa vào kết quả search MỚI NHẤT để trả lời

1. LUÔN GỌI HÀM semantic_search TRƯỚC KHI TRẢ LỜI:
   - Với MỌI câu hỏi về: quy định, học bổng, học phí, điểm, lịch học, NCKH,
     tốt nghiệp, thực tập, đăng ký môn, khen thưởng, vi phạm
   - KHÔNG TRẢ LỜI nếu chưa search!
   - KHÔNG copy câu trả lời cũ từ history!
   - CHỈ NGOẠI LỆ: Chào hỏi, cảm ơn, tạm biệt

2. CHỈ TRẢ LỜI DỰA VÀO DỮ LIỆU TRẢ VỀ TỪ SEARCH MỚI:
   - Khi semantic_search trả về danh sách ChunkDto[], ĐỌC KỸ trường 'Text'
   - CHỈ sử dụng thông tin CÓ TRONG 'Text' của các chunks MỚI
   - TUYỆT ĐỐI KHÔNG tự bịa, đoán, hoặc dùng lại câu trả lời cũ

3. NẾU KHÔNG TÌM THẤY THÔNG TIN:
   - Nếu semantic_search trả về rỗng [] hoặc không liên quan
   - Trả lời: 'Mình không tìm thấy thông tin về [chủ đề] trong tài liệu hiện có.'
   - KHÔNG copy câu trả lời cũ trong history!

4. ĐỊNH DẠNG TRẢ LỜI:
   **Trả lời:** [Câu trả lời ngắn gọn từ tài liệu MỚI search]

   **Chi tiết:**
   - Điểm 1 từ tài liệu
   - Điểm 2 từ tài liệu

   (Nguồn: [DocumentId] - Trang [PageNumber])

5. PHONG CÁCH:
   - Thân thiện: 'mình', 'bạn'
   - Rõ ràng: Chia bullet points
   - Trích nguồn: Luôn ghi (Nguồn: file - trang X)

═══════════════════════════════════════════════════════════════
NHẮC LẠI: LUÔN SEARCH MỚI, KHÔNG DÙNG CÂU TRẢ LỜI CŨ TRONG HISTORY!
═══════════════════════════════════════════════════════════════
";

    // UI & state
    private string userInput = string.Empty;
    private ElementReference messagesContainer;
    private List<MessageDTO> Messages = new();
    private List<ChatMessage> messages = new();
    private bool isStreaming = false;
    private readonly ChatOptions chatOptions = new();
    private CancellationTokenSource? currentResponseCancellation;
    private Guid? currentConversationId;
    private Guid? userId;

    [Parameter] public Guid? conversationId { get; set; }

    private const int MaxChunks = 5;
    // Giảm số lượng history để tránh AI bị ảnh hưởng bởi câu trả lời sai
    private const int MaxRecentTurnPairs = 2;

    protected override async Task OnInitializedAsync()
    {
        messages.Clear();
        messages.Add(new ChatMessage(ChatRole.System, SystemPrompt));

        try
        {
            chatOptions.Tools = new[] { AIFunctionFactory.Create(SearchAsync) };
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error registering function: {ex.Message}");
        }

        if (!conversationId.HasValue)
        {
            if (Guid.TryParse(Nav.Uri.Split('/').LastOrDefault(), out var parsedId) && parsedId != Guid.Empty)
            {
                conversationId = parsedId;
            }
        }

        if (conversationId.HasValue)
        {
            currentConversationId = conversationId;
            Messages = (await addmessage.GetMessagesByConversationAsync(conversationId.Value))?.ToList()
                       ?? new List<MessageDTO>();

            // THAY ĐỔI QUAN TRỌNG: Chỉ load messages để HIỂN THỊ UI
            // KHÔNG đưa vào context của AI để tránh lặp lại sai lầm
            messages.Clear();
            messages.Add(new ChatMessage(ChatRole.System, SystemPrompt));

            // Chỉ giữ lại một số ít câu hỏi của USER (không phải câu trả lời)
            // để AI hiểu context nhưng không bị ảnh hưởng bởi câu trả lời sai
            var recentUserQuestions = Messages
                .Where(m => m.IsUser)
                .TakeLast(MaxRecentTurnPairs)
                .ToList();

            foreach (var msg in recentUserQuestions)
            {
                messages.Add(new ChatMessage(ChatRole.User, msg.Content ?? ""));
                // Thêm placeholder để AI biết đã trả lời nhưng không copy nội dung cũ
                messages.Add(new ChatMessage(ChatRole.Assistant,
                    "[Đã trả lời trước đó - cần search lại nếu hỏi lại]"));
            }
        }

        try
        {
            var userIDString = await session.GetItemAsync<string>("UserId");
            if (!string.IsNullOrEmpty(userIDString) && Guid.TryParse(userIDString, out var guid))
            {
                userId = guid;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Chat - Error loading userId: {ex.Message}");
        }

        StateHasChanged();
        await ScrollToBottom();
    }

    /// <summary>
    /// Build messages gửi cho AI - KHÔNG bao gồm câu trả lời cũ để tránh lặp sai
    /// </summary>
    private IEnumerable<ChatMessage> BuildModelMessages(string userQuestion)
    {
        var list = new List<ChatMessage>
        {
            new ChatMessage(ChatRole.System, SystemPrompt)
        };

        // Thêm reminder để AI luôn search mới
        var searchReminder = @"
⚠️ REMINDER: Đây là câu hỏi mới. Bạn PHẢI:
1. Gọi semantic_search để tìm thông tin MỚI
2. KHÔNG được copy/dựa vào bất kỳ câu trả lời nào trước đó
3. CHỈ trả lời dựa trên kết quả search MỚI NHẤT

Câu hỏi của người dùng: " + userQuestion;

        list.Add(new ChatMessage(ChatRole.User, searchReminder));

        return list;
    }

    /// <summary>
    /// Phương thức thay thế: Giữ context nhưng thêm cảnh báo mạnh
    /// </summary>
    private IEnumerable<ChatMessage> BuildModelMessagesWithContext(string userQuestion)
    {
        var list = new List<ChatMessage>
        {
            new ChatMessage(ChatRole.System, SystemPrompt)
        };

        // Chỉ lấy các câu hỏi của user gần đây (không lấy câu trả lời)
        var recentUserMessages = messages
            .Where(m => m.Role == ChatRole.User)
            .TakeLast(MaxRecentTurnPairs)
            .ToList();

        foreach (var msg in recentUserMessages)
        {
            list.Add(new ChatMessage(ChatRole.User, msg.Text ?? ""));
            // Placeholder thay vì câu trả lời thật
            list.Add(new ChatMessage(ChatRole.Assistant,
                "[Đã xử lý - nếu hỏi lại cần search mới]"));
        }

        // Thêm câu hỏi hiện tại với reminder
        var currentQuestion = $@"
[CÂU HỎI MỚI - BẮT BUỘC SEARCH LẠI]
{userQuestion}

Lưu ý: Dù câu hỏi này có thể giống câu hỏi trước, bạn VẪN PHẢI gọi semantic_search
và CHỈ dựa vào kết quả mới để trả lời. KHÔNG copy câu trả lời cũ.";

        list.Add(new ChatMessage(ChatRole.User, currentQuestion));

        return list;
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(userInput) || isStreaming)
            return;

        CancelAnyCurrentResponse();

        var userMessage = new MessageDTO
        {
            Content = userInput,
            IsUser = true,
            ConversationId = currentConversationId ?? Guid.Empty
        };

        Messages.Add(userMessage);
        messages.Add(new ChatMessage(ChatRole.User, userInput));

        if (userId.HasValue && currentConversationId == null)
        {
            var title = userInput.Length > 50 ? userInput.Substring(0, 50) + "..." : userInput;
            var conv = new ConversationDTO { UserId = userId.Value, Title = title };
            var created = await conversation.AddConversationAsync(conv);
            if (created?.ConversationId != Guid.Empty)
            {
                currentConversationId = created.ConversationId;
            }
        }

        if (currentConversationId.HasValue)
        {
            userMessage.ConversationId = currentConversationId.Value;
            try
            {
                await addmessage.AddMessageAsync(userMessage);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error saving user message: {ex.Message}");
            }
        }

        var aiMessage = new MessageDTO { Content = string.Empty, IsUser = false, ConversationId = currentConversationId ?? Guid.Empty };
        Messages.Add(aiMessage);

        currentResponseCancellation = new CancellationTokenSource();
        var responseText = new StringBuilder();

        try
        {
            isStreaming = true;
            await InvokeAsync(StateHasChanged);

            // SỬ DỤNG BuildModelMessages MỚI - không có câu trả lời cũ
            var modelMessages = BuildModelMessages(userInput);

            await foreach (var update in ChatClient.GetStreamingResponseAsync(modelMessages, chatOptions, currentResponseCancellation.Token))
            {
                if (update.Text != null)
                {
                    responseText.Append(update.Text);
                    aiMessage.Content = responseText.ToString();
                    await InvokeAsync(StateHasChanged);
                }
            }

            if (currentConversationId.HasValue)
            {
                aiMessage.ConversationId = currentConversationId.Value;
                aiMessage.Content = responseText.ToString();
                try
                {
                    await addmessage.AddMessageAsync(aiMessage);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error saving AI message: {ex.Message}");
                }
            }

            messages.Add(new ChatMessage(ChatRole.Assistant, responseText.ToString()));
        }
        catch (OperationCanceledException)
        {
            aiMessage.Content = string.IsNullOrWhiteSpace(responseText.ToString())
                ? "Đã hủy phản hồi." : responseText.ToString();
        }
        catch (Exception ex)
        {
            aiMessage.Content = "Xin lỗi, đã xảy ra lỗi. Vui lòng thử lại.";
            Console.WriteLine($"Error calling ChatClient: {ex}");
        }
        finally
        {
            isStreaming = false;
            userInput = string.Empty;
            currentResponseCancellation?.Dispose();
            currentResponseCancellation = null;
            await InvokeAsync(StateHasChanged);
            await ScrollToBottom();
        }
    }

    private async Task ScrollToBottom()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("scrollToBottom", messagesContainer);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error scrolling: {ex.Message}");
        }
    }

    private async Task HandleKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !isStreaming)
        {
            await SendMessage();
        }
    }

    /// <summary>
    /// Dừng phản hồi đang streaming
    /// </summary>
    private async Task StopResponse()
    {
        if (currentResponseCancellation != null && !currentResponseCancellation.IsCancellationRequested)
        {
            Console.WriteLine("🛑 User requested to stop response");
            currentResponseCancellation.Cancel();

            // Cập nhật UI ngay lập tức
            isStreaming = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void CancelAnyCurrentResponse()
    {
        if (currentResponseCancellation != null)
        {
            currentResponseCancellation.Cancel();
            currentResponseCancellation.Dispose();
            currentResponseCancellation = null;
        }
    }

    [Description("Semantic search function to find relevant information. MUST be called for EVERY question about regulations, scholarships, grades, etc. Returns fresh data from documents.")]
    private async Task<IEnumerable<ChunkDto>> SearchAsync(
        [Description("Search query in Vietnamese")]
        string query,
        [Description("Max results, default 5")]
        int top_k = MaxChunks)
    {
        Console.WriteLine($"🔍 SearchAsync called: query='{query}', top_k={top_k}");

        try
        {
            var raw = await Search.SearchAsync(query, null, top_k);
            Console.WriteLine($"📊 Search returned {raw.Count} raw results");

            if (!raw.Any())
            {
                Console.WriteLine("⚠️ No results found!");
                return Enumerable.Empty<ChunkDto>();
            }

            var results = raw
                .OrderByDescending(r => r.Score)
                .Take(top_k)
                .Select(r => new ChunkDto
                {
                    DocumentId = r.Chunk.DocumentId,
                    PageNumber = r.Chunk.PageNumber,
                    Text = r.Chunk.Text ?? "",
                    Score = r.Score
                })
                .ToList();

            // Dedupe
            var deduped = new List<ChunkDto>();
            var seenTexts = new HashSet<string>();

            foreach (var chunk in results)
            {
                var normalized = chunk.Text.Trim().ToLower();
                var key = normalized.Length > 100 ? normalized.Substring(0, 100) : normalized;

                if (seenTexts.Any(s => key.Contains(s) || s.Contains(key)))
                    continue;

                seenTexts.Add(key);
                deduped.Add(chunk);
                Console.WriteLine($"✅ Chunk: {chunk.DocumentId} p{chunk.PageNumber} (score: {chunk.Score:F3})");
            }

            Console.WriteLine($"📦 Returning {deduped.Count} chunks");
            return deduped;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ SearchAsync error: {ex.Message}");
            return Enumerable.Empty<ChunkDto>();
        }
    }

    public void Dispose()
    {
        CancelAnyCurrentResponse();
        GC.SuppressFinalize(this);
    }
}